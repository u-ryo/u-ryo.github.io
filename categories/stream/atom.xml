<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title><![CDATA[u-ryo's blog]]></title><link href="http://u-ryo.github.io//categories/stream/atom.xml" rel="self"/><link href="http://u-ryo.github.io//"/><updated>2017-08-22T10:04:50+09:00</updated><id>http://u-ryo.github.io//</id><author><name><![CDATA[u-ryo]]></name></author><generator uri="http://sysgears.com/grain/">Grain</generator><entry><title type="html"><![CDATA[List to Map in Java]]></title><link href="http://u-ryo.github.io//blog/2018/08/21/list-to-map-in-java/"/><updated>2018-08-22T15:57:11+09:00</updated><id>/blog/2018/08/21/list-to-map-in-java/</id><content type="html"><![CDATA[<p>Javaで<code>List</code>を<code>Map</code>にしたかったんですね。
<a href="https://www.sejuku.net/blog/15900">【Java入門】List⇔Map変換でJava8のStreamを使う方法</a>を見ました。
ここは、いいこと書いてあるんですけど能書きが長い、Java8以前の話は不要(at least for me)、広告が多い感じがする、のが...</p>
<p>基本は単純に<code>Collectors.toMap(s-&gt;key, s-&gt;value)</code>でいけますと。
但し、duplicated keyがあった場合即Exceptionに。</p>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>jshell&gt; Stream.of(&quot;A quick brown fox jumps over the lazy dog.&quot;.split(&quot; &quot;)).collect(Collectors.toMap(s-&gt;s.length(),s-&gt;s)
</span><span class='line'>   ...&gt; )
</span><span class='line'>|  java.lang.IllegalStateException thrown: Duplicate key 5 (attempted merging values quick and brown)
</span><span class='line'>|        at Collectors.duplicateKeyException (Collectors.java:131)
</span><span class='line'>|        at Collectors.lambda$uniqKeysMapAccumulator$1 (Collectors.java:178)
</span><span class='line'>|        at ReduceOps$3ReducingSink.accept (ReduceOps.java:169)
</span><span class='line'>|        at Spliterators$ArraySpliterator.forEachRemaining (Spliterators.java:948)
</span><span class='line'>|        at AbstractPipeline.copyInto (AbstractPipeline.java:484)
</span><span class='line'>|        at AbstractPipeline.wrapAndCopyInto (AbstractPipeline.java:474)
</span><span class='line'>|        at ReduceOps$ReduceOp.evaluateSequential (ReduceOps.java:913)
</span><span class='line'>|        at AbstractPipeline.evaluate (AbstractPipeline.java:234)
</span><span class='line'>|        at ReferencePipeline.collect (ReferencePipeline.java:511)
</span><span class='line'>|        at (#9:1)
</span></code></pre></td></tr></table></div></figure>
<p>なので、<code>Collectors.toMap(s-&gt;key, s-&gt;value, (s1,s2)-&gt;do)</code>のようにduplicated keyがあった場合の処理もlambdaとして第三引数に書けます。
後勝ちの例↓</p>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>jshell&gt; Stream.of(&quot;A quick brown fox jumps over the lazy dog.&quot;.split(&quot; &quot;)).collect(Collectors.toMap(s-&gt;s.length(),s-&gt;s,(s1,s2)-&gt;s2))
</span><span class='line'>$11 ==&gt; {1=A, 3=the, 4=dog., 5=jumps}
</span></code></pre></td></tr></table></div></figure>
<p>SQLっぽく<code>Collectors.groupingBy(s-&gt;key)</code>を使うと、重複valuesはListに込めてくれるので楽です。</p>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>jshell&gt; Stream.of(&quot;A quick brown fox jumps over the lazy dog.&quot;.split(&quot; &quot;)).collect(Collectors.groupingBy(s-&gt;s.length()))
</span><span class='line'>$12 ==&gt; {1=[A], 3=[fox, the], 4=[over, lazy, dog.], 5=[quick, brown, jumps]}
</span></code></pre></td></tr></table></div></figure>
]]></content></entry><entry><title type="html"><![CDATA[Flatten lists in a list in Java]]></title><link href="http://u-ryo.github.io//blog/2018/08/21/flatten-lists-in-a-list-in-java/"/><updated>2018-08-22T15:57:11+09:00</updated><id>/blog/2018/08/21/flatten-lists-in-a-list-in-java/</id><content type="html"><![CDATA[<p>Javaでlistの中にlistが複数あるものを、
一つのflatなlistにしたい時、どうするのかなー、と。
<a href="https://qiita.com/macoshita/items/4d4aaf5cea9848ff9dbf">Java 8 で ruby の flatten</a>に書いてありました。</p>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>jshell&gt; List.of(List.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;),List.of(&quot;d&quot;,&quot;e&quot;),List.of(&quot;f&quot;,&quot;g&quot;)).stream().flatMap(Collection::stream).collect(Collectors.toList())
</span><span class='line'>$7 ==&gt; [a, b, c, d, e, f, g]
</span></code></pre></td></tr></table></div></figure>
<p><code>flatMap(Collection::stream)</code>がキモですね。
こんなの思い付かないですよ。</p>
]]></content></entry><entry><title type="html"><![CDATA[Negate Method Reference]]></title><link href="http://u-ryo.github.io//blog/2018/08/17/negate-method-reference/"/><updated>2018-08-22T15:57:11+09:00</updated><id>/blog/2018/08/17/negate-method-reference/</id><content type="html"><![CDATA[<p>Javaのstreamで、<code>filter(s -&gt; !s.isEmpty())</code>を
method referenceに出来ないかなー、と思ったんですが、
<code>java.util.function.Predicate</code>を使って、</p>
<ol>
<li>Java11だと<code>filter(Predicate.not(String::isEmpty))</code></li>
<li>現状では<code>filter(((Predicate&lt;String&gt;) String::isEmpty).negate())</code>と長くなる</li>
<li>下記のように自分で定義して<code>filter(not(String::isEmpty))</code></li>
</ol>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>public static <span class="nt">&lt;T&gt;</span> Predicate<span class="nt">&lt;T&gt;</span> not(Predicate<span class="nt">&lt;T&gt;</span> t) {
</span><span class='line'>    return t.negate();
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>
<p>cf. <a href="https://stackoverflow.com/questions/21488056/how-to-negate-a-method-reference-predicate">stack overflow: How to negate a method reference predicate</a></p>
<p>現状では長くなるので、やめました。</p>
]]></content></entry><entry><title type="html"><![CDATA[Rx as Stream API]]></title><link href="http://u-ryo.github.io//blog/2017/12/01/rx-as-stream-api/"/><updated>2017-12-01T17:41:42+09:00</updated><id>/blog/2017/12/01/rx-as-stream-api/</id><content type="html"><![CDATA[<p>周知のように、Androidではlambdaは書けるようになりましたが
Stream APIのようにCollectionsを扱えません。
折角Java8で覚えたのに。
ですが、RxJavaを使うとほぼStream APIのように書けるんですねーへーーー。
<a href="https://qiita.com/disc99/items/1b2e44a1105008ec3ac9">非同期や並列処理にも役立つRxJavaの使い方</a>
おかげでloopを回さず一文になったので、
ifの条件節に直接書けるようになりました。
<code>Optional</code>も出来るんですね。
書いてありますが、キモは<code>toBlocking().single()</code>でしょうか。</p>
]]></content></entry></feed>